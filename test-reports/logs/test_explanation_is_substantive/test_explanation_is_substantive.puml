@startuml
skinparam backgroundColor #FEFEFE
skinparam noteBorderColor #999999
skinparam noteBackgroundColor #FFFFEE
title test_explanation_is_substantive\n<size:11>[PASSED] < 75s</size>

participant "Test" as T
participant "Application" as App
participant "Engine" as Eng
participant "Orchestrator" as Orch
participant "Model" as Mdl
participant "MCP Tools" as MCP

T -> App: process_message
note right of T
  **Prompt:**
  What is recursion in programming?
end note
App -> Orch: route
note right: **NORMAL** tier
== Turn 1 ==
Orch -> Mdl: generate_stream
note right of Mdl
  **Model Output:**
  Recursion in programming occurs when a function calls itself to solve a problem 
  by breaking it into smaller, similar subproblems. It requires two key 
  components:
  
  1. **Base Case**: A condition to stop recursion (prevents infinite loops)
  2. **Recursive Case**: The function calls itself with modified parameters
  
  Example: Calculating factorial of n
  ```python
  def factorial(n):
      if n == 0:  # Base case
          return 1
      else:       # Recursive case
          return n * factorial(n-1)
  ```
  
  Key characteristics:
  - Uses call stack to manage intermediate states
  - Can lead to stack overflow if base case isn't properly handled
  - Often more elegant than iterative solutions for problems with natural 
  recursive structure (e.g., tree traversals, divide-and-conquer algorithms)
  
  Compare with iteration: Some problems are easier to solve recursively, while 
  others are better suited for loops. Modern compilers often optimize tail 
  recursion.
end note
note over T #palegreen
  **PASSED** (< 75s)
end note

@enduml