@startuml
skinparam backgroundColor #FEFEFE
skinparam noteBorderColor #999999
skinparam noteBackgroundColor #FFFFEE
title test_explanation_is_substantive\n<size:11>[PASSED] < 75s</size>

participant "Test" as T
participant "Application" as App
participant "Engine" as Eng
participant "Orchestrator" as Orch
participant "Model" as Mdl
participant "MCP Tools" as MCP

T -> App: process_message
note right of T
  **Prompt:**
  What is recursion in programming?
end note
App -> Orch: route
note right: **NORMAL** tier
== Turn 1 ==
Orch -> Mdl: generate_stream
note right of Mdl
  **Model Output:**
  Recursion in programming is a technique where a function calls itself to solve a
  problem by breaking it down into smaller, similar subproblems. It relies on two 
  key components:
  
  1. **Base Case**: A condition that stops the recursion (prevents infinite 
  loops).  
     Example: `if n == 0: return 1` in factorial calculations.
  
  2. **Recursive Case**: The function calls itself with a modified parameter to 
  reduce the problem size.  
     Example: `return n * factorial(n-1)`.
  
  ### Example: Factorial Calculation
  ```python
  def factorial(n):
      if n == 0:  # Base case
          return 1
      else:       # Recursive case
          return n * factorial(n-1)
  ```
  
  ### Key Concepts:
  - **Call Stack**: Each recursive call adds a frame to the stack until the base 
  case is reached.
  - **Stack Overflow Risk**: Deep recursion can exhaust stack memory (e.g., 
  `factorial(10000)` would crash).
  - **Tail Recursion**: Some languages optimize recursive calls to reuse stack 
  frames (not universally supported in Python).
  
  Recursion is elegant for problems with hierarchical structures (e.g., tree 
  traversals) but may be less efficient than iterative solutions for simple tasks.
  Use it when the problem naturally decomposes into subproblems.
end note
note over T #palegreen
  **PASSED** (< 75s)
end note

@enduml